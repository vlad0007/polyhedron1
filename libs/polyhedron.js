// polyhedron.js

// Каждая грань (фасета) трехмерной
// модели представлена нижеприведенной структурой Polygon.
// Структура представляет собой часть плоскости,
// ограниченной многоугольником (полигоном).
// Каждый многоугольник определяется набором 
// индексов вершин принадлежащих модели.
// Например, если грань ограничена многоугольником, 
// который можно обойти путем прохода через вершины 8, 16, 23 и 15,
// то эта грань должна быть записана в файле index.js
// в виде 8, 16, 23, 15, 8. Повторение вершины 8 говорит
// о том, что обход данной грани закончен.
// Все грани (полигоны) 3D модели обходим против часовой стрелки.
// По умолчанию в OpenGL, который является прототипом для WebGL, та сторона полигона, 
// для которой порядок перечисления вершин совпадает с обходом против часовой стрелки, 
// считается лицевой. На модель при этом, конечно, смотрим снаружи. 
// Чтобы все стало более понятным следует запустить программы Pyramid.html и Pyramid_text.html
// в которых приведена подробная нумерация вершин модели "пирамида".

function Polygon()
{
	this.IndexFacet = [];	  // индексы вершин грани с дублированной первой вершиной грани
	this.VertexFacet;         // массив, содержащий координаты каждой вершины данной грани
	this.EdgeFacet = [];      // массив, содержащий индексы, определяющие ребро грани 
							  // Kаждый элемент массива содержит два индекса вершин: begin и end.
							  //  Введен для полноты описания модели.
							  // При построении ребер моделей в текущих программах не используется, 
							  // так как ребра прорисовываются при помощи объекта THREE.Line
							  // библиотеки three.js.
	this.IndexTriangle = [];  // массив, содержащий индексы каждого треугольника, из которых состоит грань
}

function VertexFacet()
{
	this.vertexes = []; 
	this.color;
}

function Edge()
{
	this.begin;
	this.end;
};

var plgs = [];  // Массив граней из которых состоит модель.

var faces = []; // Каждый элемент этого массива состоит из трех индексов
                // треугольников, полученных после триангуляции текущей грани. 
                // Количество элементов массива равно общему количеству
                // треугольников полученных в результате триангуляции    
                // всех граней модели. 
				// В three.js используется объект Geometry и связанный с ним массив faces.
				// В дальнейшем мы используем массив faces следующим образом, например так:
				//    geometry_freshnel.faces = faces;
				//        или так:
				//    geometry_dispersion.faces = faces;  
				
var faces2 = []; // используется в тех программах в которых  
				 // есть второй экземпляр 3D-модели с той же топологией

// Создаем массив граней модели - заполняем массивы plgs и faces.
function CreatePolyhedron()
{
	var vertex = [];
	
	var i, j, k;
	
	// Координаты всех вершин модели по X, по Y и по Z записаны последовательно.
	// Поэтому необходимо брать последовательно по три числа и сформировать из
	// каждой тройки чисел координату вершины модели в виде Point3D и затем
	// поместить сформированный результат в массив vertices.
	k = 0; // k - номер в массиве вершин vertices
		   // массив vertices объявлен в другом файле
	for (i = 0; i < vertices.length/3; i++)
	{
		var pt = new Point3D();
		for (j = 0; j < 3; j++)
		{
			pt[0] = vertices[k];
			pt[1] = vertices[k + 1];
			pt[2] = vertices[k + 2];
		}
		vertex.push(pt);
		k = k + 3;
	}
	
	var index;
	var index_begin;
	var i_index = 0; // Номер индекса, проходит по всем вершинам огранки

	var iPolyg = 0;
	i = 0;
	
	for (;;) // Цикл по всем полигонам
	{
		// Полигон 
		var plg = new Polygon();  

		index = index_cut[i_index];
		i_index++; // Сразу делаем инкремент - вдруг нарвемся на "break" !!!
		if (index == -100)
			break;	// Прошли по всем полигонам

		index_begin = index; // index_begin - индекс начала новой грани
		plg.IndexFacet.push(index);
		for (;;)
		{
			// В текущем полигоне заполняем массив индексов его вершин
			index = index_cut[i_index];
			plg.IndexFacet.push(index);
			i_index++; // Берем следующую вершину текущей грани
			
			if (index == index_begin) 
			{
				// Нашли признак конца вершин для текущей грани
				var vertex_facet = new VertexFacet();
				k = 0;
				for (k = 0; k < plg.IndexFacet.length; k++)
				{
					var x = vertex[plg.IndexFacet[k]][0];
					var y = vertex[plg.IndexFacet[k]][1];
					var z = vertex[plg.IndexFacet[k]][2];
					var pt = new Point3D(x, y, z);
					vertex_facet.vertexes.push(pt);
				}
				plg.VertexFacet = vertex_facet;
				break; // все вершины текущей грани прошли
			}
		}
		// //
		//      Триангуляция выпуклого многоугольника.
		// nTriangles - кол-во треугольников в текущем полигоне
		// Если количество вершин в полигоне (с учетом последней присоединенной
		// вершины, дублирующей первую) равно N, то количество треугольников,
		// на который можно разбить выпуклый многоугольник, равно (N - 3).
		var nTriangles = plg.IndexFacet.length - 3;
		for (i = 0; i < nTriangles; i++)
		{
			var a = plg.IndexFacet[0]; // индекс первой вершины треугольника
					// на протяжении текущего цикла он остается неизменным
					// и таким образом эта вершина присутствует во всех
					// треугольниках входящих в данную грань
			var b = plg.IndexFacet[i + 1]; // индекс второй вершины треугольника
			var c = plg.IndexFacet[i + 2]; // индекс третьей вершины треугольника
			// Здесь единственное место в данном файле где используется
			// библиотека three.js, а именно THREE.Face3.
			// Если вы используете какую-либо другую библиотеку трехмерной графики,
			// то соответствующим образом измените следующие две строчки программы.
			//   Два варианта отображения модели:
			//  1. Модель разбивается на множество отдельных объектов, 
			// каждый из которых состоит из одной грани всей модели.
			plg.IndexTriangle.push(new THREE.Face3(a, b, c));  
			//  2.Все грани объединены в одну модель.
			faces.push(new THREE.Face3(a, b, c));
			if (TWO_MODELS == true) // используется в тех программах в которых  
            {   // есть второй экземпляр 3D-модели с той же топологией
			   faces2.push(new THREE.Face3(a, b, c));
			}
		}
		
		// Определяем пары индексов огранки, которые задают ребра огранки
		var nIndLines = 0;
		// Цикл по индексам грани 
		for (j = 0; j < plg.IndexFacet.length - 2; j++)
		{
			var edge = new Edge();
			edge.begin = plg.IndexFacet[j];
			if (j < plg.IndexFacet.length - 1)
				edge.end = plg.IndexFacet[j+1];
			else
				edge.end = plg.IndexFacet[0];
			
			plg.EdgeFacet.push(edge);
		}
		// Полностью заполненную очередную структуру Polygon кладем в массив plgs
		plgs.push(plg);
		iPolyg++;
	}
}