<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Chapter 1 - Pyramid (part 1)</title>
	<link rel="stylesheet" type="text/css" href="../libs/style.css">
	<script src="../libs/run_prettify.js?autoload=true&amp;lang=css" defer=""></script>
	<script type="text/javascript" src="../libs/three.js"></script>
	<script type = "text/javascript" src = "../libs/dat.gui.js"></script>
	<script src = "../libs/OrbitControls.js"></script>
	<script src = "../libs/WebGeometry.js"></script>
	<script src = "../libs/polyhedron.js"></script>
	<script src = "pyramid_1.js"></script>
</head>

	<style>
		#div_out
		{
			position: relative;
			width: 1007px;
			height: 425px;
			left: 0px;
			background-color: #aaffff;
			border: solid 2px;
		}
		#div_in
		{
			position: absolute;
			left: 5px;
			top: 5px;			
			height: 610px;
			width: 995px;
			background-color: #eeffee;
			border: solid 2px;
		}
		#div_pars
		{
			position: absolute;
			left: 505px;
			top: 2px;			
			height: 415px;
			width: 230px;
			background-color: #eeeeaa;
			border: solid 2px;
		}
		#gui_container
		{
			position: absolute;
			left: 745px;
			top: 5px;
		}
	</style>

<body>

<h3 align = "center">&emsp;&emsp;
<a href="Preface.html"> <span class=brown>Введение </span></a>  <span class=brown>&ensp;◄</span>
&emsp;&emsp;&emsp;
<a href="../index.html"> <span class=brown> Содержание  </span></a>
&emsp;&emsp;&emsp;
 <span class=brown>► &ensp;</span></a><a href="Chapter_02.html"> <span class=brown> Глава 2  </span></a>
</h3> 

<br>

<h2 align = "center"> <span class=brown>Three.js и геометрия.</span> &emsp; Глава 1 &emsp; Модель трехмерного объекта в браузере</h2>

<p>
В данной главе мы создадим нашу первую модель трехмерного объекта. 
Эта модель выпуклого многогранника по внешнему виду похожего на 
перевернутую пирамиду. Поэтому дадим этому многограннику название <b>пирамида</b>. 
Создаваемая  модель пипамиды будет иметь следующий внешний вид.
</p>


<p>
Программа созданная с помощью библиотеки <b>three.js</b> для отображения модели пирамиды:
<div id="div_out">  

	
		<canvas id="canvas" width="500" height="422" style="border: 1px solid"></canvas>
		
		<div id="div_pars" >
			<canvas id="canvas_pars" width="230" height="420"></canvas>
		</div>
	
		<div id="gui_container" ></div> 
	
	
</div>
<p>

<h3 align = "center"> Нумерация вершин граней модели</h3>
<p>
Из программы хорошо видно, что модель многогранника пирамиды условно можно разделить на три части – верхнюю, 
среднюю и нижнюю. Так как в дальнейшем мы будем создавать модели многогранников представляющих собой
ограненные драгоценные или поделочные камни, то для обозначения составных частей 
создаваемых многогранников (такие ограненные камни обычно называют <em>огранками</em>) будем придерживаться 
соответствующей терминологии принятой для огранок. 
</p>
<p>
Верхняя часть многогранника (огранки) называется <span class=blue>короной (crown)</span> .
Горизонтальная плоскость, ограничивающая корону сверху, носит название <span class=blue>площадка (table)</span>.
Средняя часть многогранника называется <span class=blue>рундистом (girdle)</span> и имеет вид пояса обернутого 
вокруг многогранника.
Нижняя часть многогранника называется <span class=blue>павильоном (pavilion)</span>. Самая нижняя вершина павильона, 
где его грани сведены в точку, называется <span class=blue>шипом</span>. Если часть павильона, 
примыкающая к шипу, ограничена плоскостью, проходящей параллельно площадке короны, 
то вместо шипа получится грань, называемая <span class=blue>калеттой (culet)</span>. 
В этом случае точку пересечения плоскостей, в которых расположены грани павильона 
будем называть <span class=blue>виртуальной калеттой</span> или 
<span class=blue>виртуальным шипом</span> многогранника (огранки). 
В дальнейшем для простоты, вне зависимости от того, что мы имеем 
в нижней части павильона – шип или калетту, мы будем обычно называть эту 
часть многогранника для единообразия калеттой. Заметим, что калетту в виде грани 
делают лишь для того, чтобы уберечь многогранник от сколов при полировке или закрепке 
в ювелирное изделие. В большинстве типов огранок, за исключением, может быть, 
классического <b>бриллианта</b> и огранки выполненной в форме <b>сердца</b>, 
чаще всего калетта стачивается до точки и, 
тем самым, устраняется ее видимость.
</p>

<p>
Три названные выше части многогранника – корона, рундист и павильон – присутствуют и в подавляющем большинстве огранок
имеющих другой внешний вид. Исключением является многогранник, называемый <b>бриолетом</b>, в которой нельзя очевидным
 образом выделить части подобные короне, рундисту или павильону.
 </p>
<p>
Перейдем непосредственно к построеню модели прамиды. Прежде всего необходимо пронумеровать ее вершины.
Для этого воспользуемся ее проволочным рисунком с нанесенным на него номерами - назовем их индексами вершин (рис.1). 
</p>
<img src = "figure_1_1.png" class="center-img" >
<p>
Введем <em>декартову систему координат</em>, в которой будем создавать модель многогранника. Начало системы координат 
поместим в точке пересечения прямой соединяющей вершины <b>6</b> и <b>8</b> 
с прямой соединяющей вершины <b>5</b> и <b>11</b> многогранника. 
Таким образом, точка начала координат окажется расположенной в центре прямоугольника, 
который образован четырьмя гранями рундиста. Оси <strong>OX</strong>, <strong>OY</strong> и <strong>OZ</strong> 
направим так, как показано на следующем рисунке. Заметим, что направление осей не совпадает с направлением осей 
в <strong>OpenGL</strong> и <strong>WebGL</strong>. При построении моделей нам удобно расположить модель 
по длине вдоль оси <strong>X</strong>, по ширине - вдоль оси <strong>Y</strong>, а по высоте - 
по оси <strong>Z</strong>.  Таким образом, отображение модели на экран производится в системе координат 
принятых в <strong>WebGL</strong>, но непосредственно сам расчет вершин модели происходит 
в системе координат, показанной на рисунке 1. Нумерация вершин показана также на рис.2.
На рисунке 2 отдельно показана нумерация вершин короны и павильона, если смотреть на корону сверху, 
а на павильон снизу. Однако, очень часто, для того чтобы положение вершин павильона было легче сопоставить 
с положением вершин короны, павильон на рисунках будет показан как будто мы смотрим на него сверху 
находясь при этом внутри многогранника.
</p>
<img src = "figure_1_2.png" class="center-img" >
<p>
Кроме нумерации всех вершин при построении модели многогранника необходимо знать, как индексы вершин 
соотносятся с гранями многогранника. Для этой цели в программе, представляющей многогранник, заводится специальный 
массив описывающий его топологию. В этот массив входит каждая грань модели, 
которая представлена номерами вершин, эту грань образующую. В дальнейшем будем придерживаться следующих правил:<br>
При нумерации (перечислении) последовательности вершин, образующих грань, направление обхода вершин 
происходит <span class=red>против часовой стрелки</span>, если мы смотрим на многогранник <span class=red>снаружи</span>.<br>
Если же наблюдатель находится <span class=red>внутри многогранника </span>, то обход вершин граней для него должен происходить 
<span class=red>по часовой стрелке</span>.
</p>
<p>
Из последовательностей пронумерованных вершин образются грани модели. Дублированная первая вершина грани 
сигнализирует о том, что грань закончилась. Нумерация (индексы) вершин хранится в массиве <code>index_cut</code>.
В дальнейшем во всех моделях многогранников самой первой в массив будем помещать грань его площадки.
Поэтому грань 0-3-2-1-0 в массиве <code>index_cut</code> расположена в начале.
<br>
<pre class="prettyprint" id="quine">
	var index_cut = [
		// Площадка многогранника  (самая верхняя грань модели)
		// Смотрим на модель сверху.
		// В пределах видимости находится площадка и грани короны.
		// Обход вершин площадки против часовой стрелки.
		0, 3, 2, 1, 0,  // грань 0

		// Корона (верхняя часть модели)
		// Смотрим на модель многогранника сверху.
		// В пределах видимости наодится площадка и грани короны.		
		// Обход вершин граней короны против часовой стрелки.
		0, 4, 7, 3, 0,  // грань 1
		1, 5, 4, 0, 1,  // грань 2
		2, 6, 5, 1, 2,  // грань 3
		3, 7, 6, 2, 3,  // грань 4

		// Рундист (средняя часть модели)
		4, 8, 11, 7, 4,  // грань 5
		5, 9, 8, 4, 5,   // грань 6
		6, 10, 9, 5, 6,  // грань 7
		7, 11, 10, 6, 7, // грань 8
		
		// Павильон (нижняя часть модели)
		// Если посмотреть на модель многогранника снизу то то обход вершин граней
		// павильона проводится также против часовой стрелки.
		12, 11, 8, 12,  // грань 9
		12, 8, 9, 12,   // грань 10
		12, 9, 10, 12,  // грань 11
		12, 10, 11, 12, // грань 12
		
		// Признак того, что граней больше нет.
		-100      
	];

</pre>

<p>
Массив <code>index_cut</code> полностью описывает структуру модели в плане взаимосвязи ее вершин и граней. 
Можно сказать, что при помощи этого массива мы задали топологию многогранника. Многогранник состоит из <em>13</em> 
граней и <em>13</em> вершин. Этот массив дальнейшем будет использован при отображении модели на экране дисплея.
</p>
<h3 align = "center"> Нумерация вершин используемая для отдельных частей модели</h3>
<p> Трехмерные моделели объектов можно условно разбить на две группы. </p>
<p>
К первой можно отнести модели объектов, которые имеют полностью регулярную единую структуру и
которые нельзя разбить на несколько отдельных частей. Ярким примером таких объектов являются <b>платоновы тела</b>,
которые являются выпуклыми многогранниками, состоящими из одинаковых правильных многоугольников и обладающих 
пространственной симметрией. К платоновым телам относятся куб, тетраэдр, октаэдр, додекаэдр и икосаэдр. Координаты всех вершин 
моделей этих многоранников рассчитываются по жестким законам - нельзя, например, произвольно изменить угол наклона
какой либо грани в платоновом многограннике, так как это нарушит его симметрию и, следовательно, объект перестанет
быть платоновым телом. Но не только <b>платоновы тела</b> можно отнести к первой группе <b>3D</b>-объектов. На сайте 
<b><a href="https://polyhedra.tessera.li/" target="_blank">Polyhedra Viewer</a></b> 
представлено большое количество многогранников, которые имеют структуру которую нельзя разбить на несколько отдельных частей.
 </p>
 <p>
 Ко второй группе отнесятся объекты, которые условно можно разделить на несколько частей. К этому классу можно 
отнести подавляющее число объектов - модели зданий (фундамент, стены, крыша), машин, мебели и т.д. 
К примеру, изменяя произвольно (в определенных пределах) координаты вершин и углы наклона граней крыши у здания
мы опять получим здание но с несколько иным внешним видом.
</p>
<p>
Модели огранок драгоценных и поделочных камней обычно состоят из трех частей - короны, рундиста и павильона. 
Допускается изменять форму любой из этих частей с целью получения максимальной красоты многогранника. 
(Исключение представляет модель огранки <em>бриолет</em>, в которой нет деления на три части.)
Расчет координат вершин короны, рундиста и павильона можно производить независимо. 
Поэтому удобно ввести дополнительную отдельную нумерацию вершин для этих трех составных частей многогранника. 
Использовать отдельные массивы для хранения координат вершин отдельных частей многогранника, для программиста 
гораздо удобнее, чем использовать единый массив для всех его вершин. Для модели пирамиды в которой 
всего тринадцать вершин это не актуально, но для многогранников в которых несколько десятков и даже сотен 
вершин отдельная нумерация делает расчет более наглядным.<br>
Для обозначения граней моделей, построением которых мы будем заниматься, условимся использовать в дальнейшем 
заглавные и (для павильонов некоторых моделей) прописные буквы латинского алфавита. 
</p>
<p>
На рисунке <b>2</b> черным цветом показана сквозная нумерация вершин
модели. Синим цветом пронумерованы вершины принадлежащие рундисту, а красным - 
короне и павильону. В программе, выполняющей построение модели многогранника, для каждой из трех ее частей заведем 
отдельный вспомогательный массив, предназначенный для хранения координат вершин соответствующей части модели. 
В дальнейшем будем называть эти массивы как <code>crown</code>, <code>girdle</code> 
и <code>pavil</code>. Для пирамиды массив <code>crown</code> содержит четыре элемента, массив <code>girdle</code> - восемь,
а массив <code>pavil</code> содержит всего один элемент. Каждый элемент, входящий в эти массивы, 
содержит значения трех нормированных на ширину многогранника значений x, y и z, которые являются координатами 
соответствующей вершины многогранника (ширина моделей принимается равной <b>1</b>). 
Указанные три массива являются необязательными и вводятся только для удобства при написании программы.
</p>
&emsp;&emsp;<a href="Pyramid_enum.html"  target="_blank"><em>Посмотреть нумерацию вершин пирамиды</em></a> в отдельном окне.
<br>
<br>
&emsp; На указанной странице при помощи переключателя <span class=blue2><b>"Crown-Gd.-Pav."</b></span> и 
<span class=blue2><b>"All vertices"</b></span> можно изменять индикацию отображения нумерации вершин модели 
(на маломощных компьютерах может пройти несколько секунд перед тем как появятся номера вершин).

<p>
В online-программе находящейся в данной главе сквозную нумерацию всех вершин можно увидеть поставив <em>галочку</em> в поле 
<b>enumeration</b> находящимся в <b>dat.GUI</b> (там где задаются значения параметров модели). При наведении
курсора мыши на любую грань модели появится поле обозначенное как "<span class=blue2>(x, y, z) =  </span>"  
в котором будут выведены соответствующие координаты точки находящейся на поверхности модели на этой грани.
</p>


<h3 align = "center"> Раскраска граней модели</h3>
<p>
На втором этапе мы можем раскрасить грани модели. Этот этап не является обязательным, если раскраска нам не нужна. 
Предположим, что мы хотим раскрасить грани так, как показано на рисунках приведенных выше на странице сайта.
С этой целью создается следующая функция
<code>facet_colors()</code>, которая осуществляет запись цветов всех граней в массив <code>colors</code>.
</p>
<p>
<pre class="prettyprint" id="quine">
	function facet_colors()
	{
		var ind = 0;

		// table
		colors[ind] = new THREE.Color("rgb(200, 200, 200)"); // 0, 3, 2, 1, 0,    грань 0
		ind++;
		
		// crown
		colors[ind] = new THREE.Color("rgb(250, 190, 190)"); // 0, 4, 7, 3, 0,    грань 1
		ind++;
		colors[ind] = new THREE.Color("rgb(190, 250, 190)"); // 1, 5, 4, 0, 1,    грань 2
		ind++;
		colors[ind] = new THREE.Color("rgb(190, 190, 250)"); // 2, 6, 5, 1, 2,    грань 3
		ind++;
		colors[ind] = new THREE.Color("rgb(150, 250, 250)"); // 3, 7, 6, 2, 3,    грань 4
		ind++;
		
		// girdle
		colors[ind] = new THREE.Color("rgb(200, 200, 200)"); // 4, 8, 11, 7, 4,   грань 5
		ind++;
		colors[ind] = new THREE.Color("rgb(170, 170, 170)"); // 5, 9, 8, 4, 5,    грань 6
		ind++;
		colors[ind] = new THREE.Color("rgb(200, 200, 200)"); // 6, 10, 9, 5, 6,   грань 7
		ind++;
		colors[ind] = new THREE.Color("rgb(170, 170, 170)"); // 7, 11, 10, 6, 7,  грань 8
		ind++;
		
		// pavilion
		colors[ind] = new THREE.Color("rgb(250, 190, 190)"); // 12, 11, 8, 12,    грань 9
		ind++;
		colors[ind] = new THREE.Color("rgb(190, 250, 190)"); // 12, 8, 9, 12,     грань 10
		ind++;
		colors[ind] = new THREE.Color("rgb(190, 190, 250)"); // 12, 9, 10, 12,    грань 11
		ind++;
		colors[ind] = new THREE.Color("rgb(150, 250, 250)"); // 12, 10, 11, 12,   грань 12
	};
</pre>
</p>

<h3 align = "center"> Выбор параметров определяющих форму и размер модели и ее отдельных частей</h3>
<p>
После того как пронумерованы все вершины и записаны последовательности обхода всех вершин граней, 
необходимо задать параметры модели и затем произвести расчет координат всех ее вершин. 
Для того чтобы построить 3D-объекта требуется знать значения координат вершин объекта в пространстве. 
Самым простым способом было бы задание массива всех координат вершин объекта напрямую – каждой вершине 
поставить в соответствие значения трех пространственных координат. Однако такой способ хорош для объекта, 
который имеет заранее определенную форму. При таком способе можно было бы пропорционально, 
с помощью масштабирования, изменять размер всего объекта и, даже, попробовать изменить размер 
объекта отдельно по каждой координатной оси. Но этот способ не позволяет изменять соотношения размеров 
отдельных частей объекта или задавать угловые размеры, присутствующие в объекте и определяющие его форму. 
Иными словами он не позволяет динамически изменять размеры и внешний вид объекта 
(в данном случае многогранника) в пределах его топологии. 
</p>
<p>
Поэтому поступим иначе. Для каждого <b>3D</b>-объекта можно определить набор некоторых характерных для 
него размеров (параметров), которые определяют его форму. Параметры могут определять либо линейные, 
либо угловые размеры частей объекта или объекта в целом. Набор параметров можно почти всегда 
определить не единственным способом. Обычно, чем сложнее объект (в данном случае многогранник), тем больше 
имеется способов задать его форму при помощи различных видов параметризации. Набор параметров для многогранника 
обычно выбирается  исходя не только из требования, создать нужную форму многогранника, но и из того, чтобы его  
модель могла взаимодействовать соответствующим образом с программой, с которой она будет совместно работать. 
На <em>рисунке <b>2</b></em> приведен вид модели сверху на корону, снизу на павильон и сбоку на всю  
<b>3D</b>-модель пирамиды с нанесенными на чертежи размерами определяющими ее форму.
Сделаем несколько предварительных замечаний.
</p>
<p>
Как для рассматриваемой модели пирамида, так для всех других многогранников, 
которые мы будем рассматривать в дальнейшем, размеры всех линейных элементов многогранника 
мы будем рассчитывать в единицах измерения отнесенных к какому-либо характерному размеру многогранника. 
Наиболее часто в качестве такого размера выступает ширина многогранника (огранки), выраженная в 
абсолютных единицах измерения. Для модели пирамиды такими единицами измерения будут, например, миллиметры.
Для моделей объектов отличных от огранок (например зданий) это могут быть метры, сантиметры и т.д. 
Но некоторые параметры моделей многогранников могут задаваться в единицах измерения отнесенных к высоте короны
или глубине павильона. Для павильона будем использовать в дальнейшем термин "глубина", так как "нулевой" 
уровень - плоскость OXY проходит через середину рундиста. Корона расположена выше этого уровня, а павильон - ниже.
</p>
<p>
Назовем шириной или главным (первым) диаметром многогранника (<code>model_width</code>) 
размер в том его месте, где производится измерение этой ширины. Обычно многогранник, относительно 
системы координат, в которой осуществляется его построение, расположен таким образом, что направление прямой, 
вдоль которой измеряется его главный диаметр, совпадает с осью <b>OY</b>. Если посмотреть на вышеприведенные 
рисунки, то как нетрудно заметить, это будет кратчайшее расстояние между ребрами образованными 
верхними вершинами рундиста <span class=blue2>0</span>, <span class=blue2>3</span> - <span class=blue2>1-2</span>. 
Или то же самое расстояние для нижних вершин рундиста 
между ребрами <span class=blue2>4-7</span> и <span class=blue2>5-6</span>. 

</p>
<p>
Будем считать, что ширина многогранника в относительных единицах всегда равна 
<code>1.0</code>. Для того чтобы перейти от относительных единиц измерения размеров элементов многогранника 
к их абсолютным значениям требуется умножить величину какого-либо его элемента, 
заданного в относительных единицах измерения, на абсолютное значение ширины многогранника. 
Ширина многогранника в абсолютных единицах равна (<code>model_width · 1.0)</code>. 
Если <code>model_width = 6mm</code>, то ширина многогранника равна <code>6mm · 1.0 = 6mm</code> и таким 
образом совпадает с численным значением параметра <code>model_width</code>. 
Во всех многогранниках, которые мы будем создавать в дальнейшем, если специально не будет оговорено, 
будем считать, что ширина многогранника в относительных единицах измерения равна <code>1.0</code> и при этом 
ширина многогранника будет измеряться по оси <b>OY</b>. Исключением из правила представляют собой огранки 
типа сердце – их ширину будем измерять вдоль оси <b>OX</b>. Размер многогранника по оси <b>OX</b> (кроме огранок 
типа сердце) мы назовем длиной или вторым диаметром многогранника (<span class=blue>"Second Diameter"</span>). 
Если ввести отношение <code>lw</code> длины многогранника (огранки) к его ширине (<code>length / width</code>) 
то значение второго диаметра в абсолютных единицах длины будет равно 
<code>model_width · lw</code>, а в относительных единицах это значение будет равно 
непосредственно <code>lw</code>.
</p>
<p>
Абсолютные значения ширины и длины модели можно задать (если речь идет об огранках драгоценных камней) 
в миллиметрах. Линейные относительные размеры элементов модели многогранника задаются в процентах. 
В большинстве случаев размеры в процентах задаются относительно ширины модели, но иногда, как уже говорилось, 
они могут быть заданы и относительно других линейных размеров – например, относительно размера,
определяющего глубину павильона. 
При этом сама глубина павильона обычно задается в процентах от значения относительного 
размера ширины модели. Угловые значения параметров задаются в градусах. 
Встречаются еще параметры значения, которых должны быть представлены в виде вещественных чисел. 
В качестве примера такого параметра можно привести уже упоминавшийся параметр <code>lw</code>, 
задающий так называемое удлинение модели – отношение ее длины к ширине.
</p>
<p>
Для рассматриваемой модели пирамиды мы введем следующие параметры, которые позволят рассчитать 
координаты каждой ее вершины и позволят изменять форму и размер многогранника при изменении значений 
этих параметров.<br>
1. <span class=par>model_width</span> – ширина (диаметр) многогранника в абсолютных единицах длины (mm).<br>
2. <span class=par>lw</span> – отношение длины модели к ее ширине (<code>length / width</code>).<br>
3. <span class=par>r</span> – толщина рундиста измеряемая вдоль оси <b>OZ</b>.<br>
4. <span class=par>t</span> – ширина короны, которая измеряется по направлению главного диаметра многогранника<br>
5. <span class=par>hCrown</span> – высота короны.<br>
6. <span class=par>hp</span> – глубина павильона.<br>
</p>
<p>
Параметры <code>r, t, hCrown, hp</code> измеряются в процентах от ширины модели. 
На вышележащем рисунке показано профильное изображение пирамиды. Из него можно увидеть, 
каким образом определены значения <code>r, t, hCrown, hp</code>. Если исключить из шести перечисленных 
параметров модели параметр, задающий ее абсолютную ширину (<code>model_width</code>), то пять оставшихся 
параметров позволяют полностью определить форму модели пирамиды и относительные размеры всех ее элементов. 
Значение <code>model_width</code> по существу определяет только размер огранки - он принят равным <b>1.0</b>.
<br>
В программе на javascript это выглядит следующим образом:
</p>
<pre class="prettyprint" id="quine">Ы
var model_width = 1.0; // размер модели
var lw = 1.2;          // отношение длина/ширина
var r = 0.06;          // высота рундиста
var t = 0.6;           // размер площадки
var hCrown = 0.3;      // высота короны
var hp = 0.6;          // глубина павильона
</pre>

<h3 align = "center"> Структура данных модели (<b>СДМ</b>)</h3>
<p>
Значения этих шести параметров образуют структуру, которой мы дадим название структура данных модели 
(сокращенно <b>СДМ</b>). Входящие в <b>СДМ</b> элементы в дальнейшем будем 
называть или параметрами или полями <b>СДМ</b>.
Модель пирамидs достаточно простая. Выбор параметров для нее очевиден. 
Хотя не сложно придумать и другой, отличный от рассмотренного выше, набор параметров. 
Выбор параметров определяется разработчиком модели. Например, вместо задания параметра 
<code>hCrown</code> можно задать в <b>СДМ</b> угол наклона грани 
<b>A</b> короны. Тогда высоту короны в дальнейшем можно найти по формуле: 
<pre class="prettyprint" id="quine">
hCrown = (0.5 - t/2) * Math.tan(crownAngle_A);
</pre>
</p>
<p>
Можно поступить и так - в <b>СДМ</b> не вводить параметр <code>t</code> (размер площадки), 
а ввести углы наклона граней граней <b>A</b> и <b>B</b> короны и высоту короны <code>hCrown</code>. 
Затем создать плоскости в которых лежат грань <b>A</b>, грань <b>B</b> 
и грань площадки <b>Table</b>. После этого точки пересечения этих плоскостей определят 
координаты вершин площадки.
</p>
<p> 
Не желательной считается ситуация, когда в <b>СДМ</b> есть некоторое поле, но пользователь 
модели доступа к нему не имеет. Хотя наличие такой ситуации нельзя считать ошибкой, 
но все же ее следует избегать, так как они определяют форму модели и должны быть всегда доступны пользователю.
Иногда поля в в <b>СДМ</b> к которым в данной программе пользователь этой программы не 
имеет доступа и эти поля хранят фиксированные значения, все-таки вводятся с прицелом их 
изменения в будущем варианте модели многогранника.
Но категорически не следует в полях <b>СДМ</b> хранить какие-либо промежуточные результаты вычислений получаемых 
в процессе построения огранки или другие величины, не относящиеся к параметрам, определяющим форму модели.
</p>
<p> 
Кроме тех параметров, которым однозначно соответствуют значениям полей в <b>СДМ</b>, существуют 
еще так называемые вычисляемые параметры, для которых в <b>СДМ</b> не предусмотрены 
соответствующие им поля. Для таких параметров также предусмотрена возможность получения их значений и, 
возможно, изменения этих значений. Вычисляемые параметры получают свои значения исходя из значений 
других параметров, чьи поля присутствуют в <b>СДМ</b>.<br>
Например, если в <b>СДМ</b> присутствует поле <code>hp</code>, задающее глубину павильона, 
то, используя это значение, можно вычислить значение параметра <span class=blue>"Pav. angle B1"</span>
(<code>anglePav</code>), определяющего угол наклона передней грани павильона, и вывести значение 
угла наклона в соответствующем элементе отображения. Однако, поля, соответствующего параметру с именем 
<span class=blue>"Pav. angle B1"</span> в <b>СДМ</b> нет, так как угол наклона 
передней грани павильона зависит при фиксированной ширине огранки только от глубины павильона, 
а для глубины павильона уже существует соответствующее поле в <b>СДМ</b>. 
В <b>СДМ</b> не могут одновременно присутствовать поля, предназначенные и для значения 
глубины павильона и для значения угла наклонапередней грани павильона.  В <b>СДМ</b> 
может присутствовать только один из этих двух параметров, так как их значения однозначно зависят друг от друга. 
Но ничто нам не мешает для вычисляемого параметра <span class=blue>"Pav. angle B1"</span>, 
завести дополнительный элемент управления <code>anglePav</code> для его изменения. При этом соответствующим 
образом будет изменяться значение параметра определяющего глубину павильона в <b>СДМ</b>. 
</p>
<p>
Резюмируя вышесказанное, отметим, что кроме параметров входящих в <b>СДМ</b> можно создать 
так называемые вычисляемые параметры 3D-модели.  При изменении этих параметров, параметры входящие в 
<b>СДМ</b> (и, возможно, другие вычисляемые параметры, которые могут не входить в 
<b>СДМ</b>) будут менять свои значения.<br>
Вычисляемые параметры могут быть, в свою очередь, двух типов. <br>
Для первого типа вычисляемых параметров значение параметра можно только увидеть в окне пропредназначенном 
для отображения значений параметров, но изменение их значения выполнить невозможно. 
Иначе говоря, значение такого параметра доступно  только для чтения (<span class=red>read-only</span>).<br>
Для второго типа вычисляемых параметров можно не только считывать значение параметров,  но еще и задавать или 
изменять эти значения. Например, возвращаясь к примеру с параметром <span class=blue>"Pav. angle B1"</span> 
(<code>anglePav</code>), очевидно, что значение угла наклона павильона можно и считывать и задавать. 
Но в случае, когда значение этого параметра изменяется пользователем модели, потребуется пересчитать значение
глубины павильона и затем изменить значение поля <code>hp</code> в <b>СДМ</b>.
<p>
<h3 align = "center"> Координаты вершин модели пирамиды</h3> 
<p>
Расчет координат модели пирамиды производится функцией <code>VerticesCalculation</code>. 
Для модели пирамида этот расчет тривиален и его понимание не представляет затруднений, 
но для большинства других моделей он является достаточно сложной задачей. Поэтому скажем про него несколько слов.
Так как модели многогранников (огранок) обычно состоят из трех частей - рундиста, короны и павильона то следует 
выбрать ту часть модели с которой мы начнем расчет. Так как связующим звеном между короной и павильоном является 
рундист, то расчет координат его вершин целесообразно производить первым. Поэтому внутри функции 
<code>VerticesCalculation</code> вызывается функция <code>InitGirdle</code>. После этого можно 
переходить к расчету  координат короны и павильона - при этом мы будем опираться на рассчитанные 
координаты вершин рундиста. Результаты расчета координат вершин заносятся  в массив <code>vertices</code>. 
</p>
<p>
При расчете в этой функции используется библиотека <b>WebGeometry</b>. При расчете в этой функции используется 
библиотека <b>WebGeometry</b>. 
<a href="../libs/Help.html"  target="_blank"><b>Подробная документация по библиотеке WebGeometry.</b></a> 
Пока из этой библиотеки мы испорльзуем только
функцию создания <b>3D</b>-вершины <a href="../libs/Help.html#Point3D"  target="_blank">
 <code>Point3D</code></a>. Применение остальных функций будет рассмотрено в следующих частях.
</p>
<p>
Заметим, что в программе нахождения координат вершин применяются отдельные последовательности номеров 
для вершин входящих в состав короны (четыре вершины), вершин входящих в состав рундиста (четыре вершины) 
и вершин входящих в состав павильона (в модели пирамида в состав павильона входит только вершина). 
Такой выбор дополнительной нумерации вершин применяется для более простой ориентации программистом среди 
вершин многогранников, так как количество вершин очень часто превышает число <code>100</code>.
</p>
<p>
После того как координаты вершин короны, рундиста и павильона рассчитаны в единицах измерения относительно 
ширины модели и помещены в массивы <code>crown</code>, <code>girdle</code> 
и <code>pavil</code>, необходимо пересчитать эти координаты в абсолютные значения, которые измеряются 
в mm для огранок. С этой целью значения координат <b>x</b>, <b>y</b> и <b>z</b> вершин 
умножаются на масштабный множитель <code>model_width</code>. В качестве него выступает 
ширина многогранника. Заметим, что параметр <code>model_width</code> используется только для пирамиды - для моделей,
которые будут созданы в дальнейшем мы будем принимать их ширину всегда равной <code>1.0</code>
и поэтому данный пересчет для других моделей в дальнейшем производиться не будет.
Еще раз отметим, что создание модели пирамиды предельно просто и массивы <code>crown</code>, 
<code>girdle</code>, <code>pavil</code> можно было не вводить. Они введены только для иллюстрации 
того, как мы будем производить расчеты других моделей в дальнейшем.
</p>

<p>
<pre class="prettyprint" id="quine">
// Расчет координат вершин многогранника.
var girdle = [8];
function VerticesCalculation()
{
	InitGirdle ();
	
	// Вспомогательные массивы
	var crown = [4];
	var pavil = [1];
	
	// Координаты вершин короны в % к ширине многогранника
	crown[0] = new Point3D(   0.5 * t * lw,   0.5 * t, hCrown + r/2);
	crown[1] = new Point3D(   0.5 * t * lw, - 0.5 * t, hCrown + r/2);
	crown[2] = new Point3D( - 0.5 * t * lw, - 0.5 * t, hCrown + r/2);
	crown[3] = new Point3D( - 0.5 * t * lw,   0.5 * t, hCrown + r/2);

	pavil[0] = new Point3D(0.0, 0.0, -hp);
	
	// Заполняем массив vertices.
	var i;
	for(i = 0; i < 4; i++)
	{
		vertices.push(model_width * crown[i][0]);
		vertices.push(model_width * crown[i][1]);
		vertices.push(model_width * crown[i][2]);
	}
	for(i = 0; i < 8; i++)
	{
		vertices.push(model_width * girdle[i][0]);
		vertices.push(model_width * girdle[i][1]);
		vertices.push(model_width * girdle[i][2]);
	}
	for(i = 0; i < 1; i++)
	{
		vertices.push(model_width * pavil[i][0]);
		vertices.push(model_width * pavil[i][1]);
		vertices.push(model_width * pavil[i][2]);
	}								 
}

function InitGirdle ()
{
	girdle[0] = new Point3D(  lw * 0.5,   0.5,   r/2);
	girdle[1] = new Point3D(  lw * 0.5, - 0.5,   r/2);
	girdle[2] = new Point3D(- lw * 0.5, - 0.5,   r/2);
	girdle[3] = new Point3D(- lw * 0.5,   0.5,   r/2);
	girdle[4] = new Point3D(  lw * 0.5,   0.5, - r/2);
	girdle[5] = new Point3D(  lw * 0.5, - 0.5, - r/2);
	girdle[6] = new Point3D(- lw * 0.5, - 0.5, - r/2);
	girdle[7] = new Point3D(- lw * 0.5,   0.5, - r/2);
}
</pre>
</p>

<h3 align = "center"> Отображение граней модели в three.js и WebGL</h3> 

<div>
<img src = "figure_1_3.png" class = "left-img1" >
<p>
При использовании для отображения моделей <b>OpenGL</b> c <em>фиксированным конвейером</em> мы могли рисовать 
не только треугольники но и многоугольники с числом вершин более трех при помощи задания параметра
<code>GL_POLYGON</code> в соответствующей части программы. <b>OpenGL 2.0</b> и более поздние 
версии (а также <b>WebGL</b> и созданная на его основе библиотека <b>three.js</b>) используют <em>программируемый  
конвейер</em> в котором все полигоны необходимо предварительно разбить на треугольники. Поэтому, используя массив 
<code>index_cut</code> в качестве исходного, необходимо произвести <em>триангуляцию</em> 
всех граней модели. В приведенном ниже исходном тексте (файл <b>polyhedron.js</b>) находится  функция 
<code>CreatePolyhedron</code>, которая производит триангуляцию. Входными данными для этой
функции являются, как сказано выше, массив номеров вершин <code>index_cut</code>, а также  
массив со значениями координат всех вершин <code>vertices</code>.
</p>
<p>
В результате работы функции <code>CreatePolyhedron</code> мы получаем два массива 
<code>plgs</code> и <code>faces</code>.
<br>
Массив <code>plgs</code> содержит информацию о каждом <i>полигоне</i> (<i>многоугольнике</i>) 
входящем в модель. Каждый элемент этого массива включает, в том числе, и всю информацию о входящем
в полигон треугольниках составляющих этот полигон. Количество элементов входящих в массив 
<code>plgs</code> равно количеству граней модели.
<br>
Массив <code>faces</code> содержит информацию о каждом <i>треугольнике</i> входящем в модель
без привязки треугольниов к конкретным граням модели. Количество элементов входящих в массив 
<code>faces</code> равно количеству всех треугольников входящих в уже триангулированную модель.
</p>
<p>
Работа функции <code>CreatePolyhedron</code> подробно описана в комментариях к ее исходному коду.
На рисунке <b>4</b> приведена взаимосвязь всех структур используемых в функции.
</p>
</div>
<pre class="prettyprint" id="quine">
// polyhedron.js

function Polygon()
{
   this.IndexFacet = [];// индексы вершин грани с дублированной первой вершиной грани
   this.VertexFacet;	// массив, содержащий координаты каждой вершины данной грани
   this.IndexTriangle = [];  // массив, содержащий индексы каждого треугольника, 
								// из которых состоит грань
   
   this.EdgeFacet = []; // массив, содержащий индексы, определяющие ребро грани 
			// Kаждый элемент массива содержит два индекса вершин: begin и end.
			//  Введен для полноты описания модели.
			// При построении ребер моделей в текущих программах не используется, 
			// так как ребра прорисовываются при помощи объекта THREE.Line 
			// библиотеки three.js.
}
	
function VertexFacet()
{
	this.vertexes = []; 
	this.color;
}

function Edge()
{
	this.begin;
	this.end;
};

var plgs = [];  // Массив граней из которых состоит модель.

var faces = []; // Каждый элемент этого массива состоит из трех индексов
		// треугольников, полученных после триангуляции текущей грани. 
		// Количество элементов массива равно общему количеству
		// треугольников полученных в результате триангуляции    
		// всех граней модели. 
		// В three.js используется объект Geometry и связанный с ним массив faces.
		// В дальнейшем мы используем массив faces следующим образом, например так:
		//    geometry_freshnel.faces = faces;
		//        или так:
		//    geometry_dispersion.faces = faces;  

var faces2 = []; // используется в тех программах в которых  
				 // есть второй экземпляр 3D-модели с той же топологией
				 
// Создаем массив граней модели - заполняем массивы plgs и faces.
function CreatePolyhedron()
{
	var vertex = [];
	var i, j, k;
	// Координаты всех вершин модели по X, по Y и по Z записаны последовательно.
	// Поэтому необходимо брать последовательно по три числа и сформировать из
	// каждой тройки чисел координату вершины модели в виде Point3D и затем
	// поместить сформированный результат в массив vertices.
	k = 0; // k - номер в массиве вершин vertices
		   // массив vertices объявлен в другом файле
	for (i = 0; i < vertices.length/3; i++)
	{
		var pt = new Point3D();
		for (j = 0; j < 3; j++)
		{
			pt[0] = vertices[k];
			pt[1] = vertices[k + 1];
			pt[2] = vertices[k + 2];
		}
		vertex.push(pt);
		k = k + 3;
	}
	
	var index;
	var index_begin;
	var i_index = 0; // Номер индекса, проходит по всем вершинам многогранника
	var iPolyg = 0;
	i = 0;
	for (;;) // Цикл по всем полигонам
	{
		// Полигон 
		var plg = new Polygon();  

		index = index_cut[i_index];
		i_index++; // Сразу делаем инкремент - вдруг нарвемся на "break" !!!
		if (index == -100)
			break;	// Прошли по всем полигонам

		index_begin = index; // index_begin - индекс начала новой грани
		plg.IndexFacet.push(index);
		for (;;)
		{
			// В текущем полигоне заполняем массив индексов его вершин
			index = index_cut[i_index];
			plg.IndexFacet.push(index);
			i_index++; // Берем следующую вершину текущей грани
			
			if (index == index_begin) 
			{
				// Нашли признак конца вершин для текущей грани
				var vertex_facet = new VertexFacet();
				k = 0;
				for (k = 0; k < plg.IndexFacet.length; k++)
				{
					var x = vertex[plg.IndexFacet[k]][0];
					var y = vertex[plg.IndexFacet[k]][1];
					var z = vertex[plg.IndexFacet[k]][2];
					var pt = new Point3D(x, y, z);
					vertex_facet.vertexes.push(pt);
				}
				plg.VertexFacet = vertex_facet;
				break; // все вершины текущей грани прошли
			}
		}
		//      Триангуляция выпуклого многоугольника.
		// nTriangles - кол-во треугольников в текущем полигоне
		// Если количество вершин в полигоне (с учетом последней присоединенной
		// вершины, дублирующей первую) равно N, то количество треугольников,
		// на который можно разбить выпуклый многоугольник, равно (N - 3).
		var nTriangles = plg.IndexFacet.length - 3;
		for (i = 0; i < nTriangles; i++)
		{
			var a = plg.IndexFacet[0]; // индекс первой вершины треугольника
					// на протяжении текущего цикла он остается неизменным
					// и таким образом эта вершина присутствует во всех
					// треугольниках входящих в данную грань
			var b = plg.IndexFacet[i + 1]; // индекс второй вершины треугольника
			var c = plg.IndexFacet[i + 2]; // индекс третьей вершины треугольника
			// Здесь единственное место в данном файле где используется
			// библиотека three.js, а именно THREE.Face3.
			// Если вы используете какую-либо другую библиотеку трехмерной графики,
			// то соответствующим образом измените следующие две строчки программы.
			//   Два варианта отображения модели:
			//  1. Модель разбивается на множество отдельных объектов, 
			// каждый из которых состоит из одной грани всей модели.
			plg.IndexTriangle.push(new THREE.Face3(a, b, c));  
			//  2.Все грани объединены в одну модель.
			faces.push(new THREE.Face3(a, b, c));
			if (TWO_MODELS == true) // используется в тех программах в которых  
			{   // есть второй экземпляр 3D-модели с той же топологией
				faces2.push(new THREE.Face3(a, b, c));
			}			
		}
		
		// Определяем пары индексов многогранника, которые задают его ребра
		var nIndLines = 0;
		// Цикл по индексам грани 
		for (j = 0; j < plg.IndexFacet.length - 2; j++)
		{
			var edge = new Edge();
			edge.begin = plg.IndexFacet[j];
			if (j < plg.IndexFacet.length - 1)
				edge.end = plg.IndexFacet[j+1];
			else
				edge.end = plg.IndexFacet[0];
			
			plg.EdgeFacet.push(edge);
		}
		// Полностью заполненную очередную структуру Polygon кладем в массив plgs
		plgs.push(plg);
		iPolyg++;
	}
}
</pre>
</p>

<img src = "figure_1_4.png" class="center-img-rounded" border = "2px" >

<p>
В результате работы <code>CreatePolyhedron</code> мы ролучили, до некоторой степени, 
дублированные массивы <code>plgs</code> и <code>faces</code>.
<p>
Массив <code>plgs</code> используется в том случае когда каждая грань модели создается как
отдельный объект (<i>mesh</i>). Это сделано по двум причинам.
<br>
Во-первых отдельные меши граней легче раскрасить специально, наперед заданными цветами, 
чем раскрашивать отдельные грани модели, если они входят как части в единую модель многогранника. 
<br>
Во-вторых, если мы при помощи "<i>raycaster</i>" будем выбирать отдельные грани многогранника, то удобнее, 
на мой взгляд, использовать модель составленную из отдельных мешей граней.
</p>
<p>
Массив <span class=jp>faces</span> используется в том случае когда все грани модели
объединены в один объект (единый <i>mesh</i>). Такой подход предпочтителен, когда для отображения модели
используются специальные шейдеры. Это продемонстрировано на моделях многогранников 
<a href="https://vlad0007.github.io/"  target="_blank"><b>Octagon, Brilliant, MoonMarquise,</b></a> ... в режимах 
работы программы, когда соответствующие модели отображаются с использованием шейдеров 
<span class=blue>Fresnel</span> и <span class=blue>Dispersion</span>. 
<p>
В следующей главе мы создадим программу отображения модели пирамида построенный на основе
рассмотренных структур данных и в которой все грани пирамиды объединены в единый меш и использовано
освещение. Но в основном следующая глава будет посвещена подробному описанию программы данной главы.
</p>
<h3 align = "center">&emsp;&emsp;
<a href="Preface.html"> <span class=brown>Введение </span></a>  <span class=brown>&ensp;◄</span>
&emsp;&emsp;&emsp;
<a href="../index.html"> <span class=brown> Содержание  </span></a>
&emsp;&emsp;&emsp;
 <span class=brown>► &ensp;</span></a><a href="Chapter_02.html"> <span class=brown> Глава 2  </span></a>
</h3> 

</body>
</html>
